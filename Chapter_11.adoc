:toc-placement!:
:imagesdir: ./

== Chapter 11. Working With Files  

After a program ends it gets erased from memory. When you run it again, its content is loaded into memory and all Java objects are created from scratch. If you’d like to save some results of the program execution, they must be stored in files on a hard disk, a solid-state drive, a memory stick, or other device that can store the data for a long time.  

In this chapter you’ll learn how to save data on disks and read them back into memory using Java Input/Output(I/O) streams.A program can open an _output stream_ with a file on disk and write the important data there. Similarly, you can open an _input stream_ and read the data from a file. 

For example, if a player wins a game and  you want to save the score, you can save it in a file called scores.txt using an output stream. If you want to save the player's preferences (e.g. colors or fonts) you can save them in a file, and read and apply them when the user runs your program again.

A program reads or writes data from/to a stream serially – byte after byte, character after character, etc.  Since your program may use different data types like `String`, `int`, `double`, you should use an appropriate Java stream, for example a byte stream, a character stream, or a data stream. 

In this chapter I'll show you how to use I/O streams with files located in your computer. In the next chapter you'll learn about I/O streams that can work with remote data located in other computers connected into a network. 

All classes that can work with file streams are located in packages  `java.io` and `java.nio`.  Classes from the `java.io`  
implement blocking I/O: When bytes are being read/written, they become unavailable for other threads of execution. This may not be an issue with small files like a history of game scores, but may become an issue with large files that contain a gigabyte or more. The package `java.nio` offers a set of classes with improved performance as well as some useful utility classes.

I'll start with explaining you the basics of working with streams of bytes using classes from the `java.io` package, and then give you some examples of working with classes from `java.nio`.

=== Basics of Working With Streams

Think of a stream as a pipe. If you just need to read the data you have one pipe where the data flow through this pipe from the data source into your program. If you need to write the data into a storage, it's another pipe where the data flow from your program. As with any pipe, it has to be opened to start the flow and closed to stop it.

Java supports several types of streams, but no matter what type you are going to use, the following three steps should be done in your program:

• Open a stream that points at some data store e.g. a local or remote file.

• Read or write data from/to this stream. 

• Close the stream (Java can do it automatically).
 
In the real world people use different types of pipes for carrying different contents (e.g. gas, oil, milkshakes). Similarly, Java programmers use different classes depending on the type of data they need to carry over a stream. Some streams are used for carrying text, some for bytes, et al. 

==== Byte Streams

To create a program that reads a file, interprets and displays its content on the screen, you need to know what type of data is stored in this file. On the other hand, a program that just copies files from one place to another, does not even need to know is it an image, a text, or a file with music. Such a copy program reads the original file in memory as a _set of bytes_, and then writes them into a destination folder.. 

Originaly `java.io` package have not offered a fast way to copy files and you'd need to write a program that reads byte after byte using Java classes `FileInputStream` or `FileOutputStream`.

If your program has to work only with text files, you could use the classes `Reader` and `Writer`, which are specifically meant for reading character streams. 

After selecting the appropriate class you'll be invoking one of its methods to read or write the file. For example the http://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html[online documentation] of the class `FileInputStream` includes the method `read` having the following signature:

[source, java]
----
public int read() throws IOException
----

This should tell you that the method `read` returns an integer value and may throw the `IOException`, which is an error that may happen if the file is corrupted or deleted, a device failure happened et al. Hence, you must enclose the invocation of the method `read` into a try-catch block as explained in Chapter 9. To get a specific reason of this exception you'll call the method `getMessage` on the exception object.

Each byte in a file is represented by a code, which is a positive integer number. The method `read` returns the value of this code.

The next example shows how to use the class `FileInputStream` to read the bytes from a file named _abc.dat_. This little program won't interpret the meaning of each byte - it'll just print their code values.

I'll start with creating a new Java project _Chapter11_ in IDEA. Then I'll create a new empty file _abc.dat_ in the root folder of the project (right-click on the project name and select the menu New | File). Finally, I'll type the following text in _abc.dat_:

_This is a test file_

Then I'll create a new Java class `MyByteReader` that will read and print the content of the file _abc.dat_. But let's pretend that we don't know that the content of this file is text - I want to read it byte by byte and print each byte's code (not a letter) separated by a space character. The class `MyByteReader` will look like this:

[source, java]
----
import java.io.FileInputStream;              
import java.io.IOException;

public class MyByteReader {

  public static void main(String[] args) {

    try (FileInputStream myFile =             // <1>
              new FileInputStream("abc.dat")){

      int byteValue;

      while ((byteValue = myFile.read()) != -1) { // <2>

          System.out.print(byteValue + " ");   // <3>
      }
    } catch (IOException ioe) {                // <4>
        System.out.println("Could not read file: " +
                ioe.getMessage());
    }
  }
}
----

<1> First we open the file for reading (using a default character set) by creating an instance of the class `FileInputStream` passing the file name `abc.dat` as a parameter. In Chapter 9 you've learned the syntax of the try-catch blocks. But here I use a special syntax called _try-with-resources_. When there are some program resources that has to be opened and closed (e.g. `FileInputStream`), just instantiate them in parentheses right after the `try` keyword and Java will close them for you automatically. This spares you from writing a `finally` block containing the code for closing resources.

<2> This line starts a `while` loop that calls the method `read()`, which reads one byte, assigns its value to the variable `byteCode`, and compares it with `-1` (the end of file indicator). 

<3> If the value in the current byte is not equal to `-1`, we print it followed by a space character. The loop ends when it reads the `-1` byte. 

<4> If an `IOException` occurs, catch it and print the reason of this error.

Running this program prints the following numbers that represent encoding of the text "This is a test file":

[source, java]
----
84 104 105 115 32 105 115 32 97 32 116 101 115 116 32 102 105 108 101 
----

Writing bytes into a file works similarly, but you'd use the class `FileOutputStream` and its method `write()` as shown in the program `MyByteWriter` below.

[source, java]
----
import java.io.FileOutputStream;
import java.io.IOException;

public class MyByteWriter {

  public static void main(String[] args) {

    // Some byte values represented by integer codes
    int someData[]= {56,230,123,43,11,37};   // <1>

    try (FileOutputStream myFile = new FileOutputStream("xyz.dat")){            // <2>

        int arrayLength = someData.length;

        for (int i = 0; i < arrayLength; i++){
            myFile.write(someData[i]);        // <3>
        }
    } catch (IOException ioe) {
        System.out.println("Could not write into the file: " + ioe.getMessage());     //  <4>
    }
  }
}
----

<1> The program `MyByteWriter` populates an array `someData` with integer codes that may represent some characters

<2> Then the program opens the file _xyz.dat_ 

<3> and writes each of the integers into the file.

<4> If an error occurs, we catch it and print the reason.

==== Bufferred Streams

The code examples in the Byte Streams section were reading or writing into a a file one byte at a time. One invocation of `read` would read one byte, and one invocation of `write` would write one byte. In general, disk access is much slower than the processing performed in memory; that’s why it’s not a good idea to access the disk a thousand times to read a file of 1,000 bytes. To minimize the number of times the disk is accessed, Java provides buffers, which serve as reservoirs of data.

[[FIG11-1]]
image::images/fig_11_BufferedStream.png[]

The class `BufferedInputStream` works as a middleman between `FileInputStream` and the file itself. It reads a big chunk of bytes from a file into memory (a buffer) in one shot, and the `FileInputStream` object then reads single bytes from there, which are fast memory-to-memory operations. `BufferedOutputStream` works similarly with the class `FileOutputStream`.

The main idea here is to minimize disk access.
Buffered streams are not changing the type of the original streams — they just make reading more efficient. A program performs stream chaining (or stream piping) to connect streams, just as pipes are connected in plumbing. 

The next code listing shows a class `MyBufferedByteReader`, which is a slightly modified version of `MyByteReader`. I just attached "another fragment to the pipe" - the `BufferedInputStream` from the `java.io` package.

[source, java]
----
import java.io.BufferedInputStream;
import java.io.FileInputStream;
import java.io.IOException;

public class MyBufferedByteReader {

  public static void main(String[] args) {

    try (FileInputStream myFile = new      // <1>FileInputStream("abc.dat");
         BufferedInputStream buff = new 
         BufferedInputStream(myFile);){

        int byteValue;

        while ((byteValue = buff.read()) != -1) { // <2>

            System.out.print(byteValue + " ");
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
  }
}
----

<1> Here we use the try-with-resources syntax again. This time we create an instance of `FileInputReader` and then and instance of `BufferedInputReader` providing the `FileInputReader` as an argument. This is how we connect to fragments of the pipe that uses the file _abc.dat_ as the source of data.

<2> Under the hood the `BufferedInputReader` reads  bytes from disk in chunks into a memory buffer, and then the method `read` reads one byte at time from memory.

The program `MyBufferedByteReader` produces the same output as `MyByteReader`, but will work just a little bit faster.

=== Character Streams

Text in Java is represented as a set of `char` values, which are encoded based on the character sets capable to represent alphabet or other symbols used in a particular human language. As you can imagine, the text in English, Ukrainian, and Japanese should use different character encodings. The names of some of the standard character sets for English-speaking people are US-ASCII, UTF-8, and UTF-16. 

Each JVM has a default character set, which could be changed during the JVM startup. You can also find out what's the default character in your Java installation by invoking the method `defaultCharset` on the class `Charset`, and I'll show how to do it in the section "Reading Text Files".

The Java classes `FileReader` and `FileWriter` from the package `java.io` were specifically created to work with text files, but they work only with default character encoding and don’t handle localization properly.
 
For efficiency, the reading can be piped with the `BufferedReader` or `BufferedWriter`, which read or write from/to the stream buffering characters. I'll show you examples of working with text files in the next section. 


=== Working With Files Using java.nio

The `java.nio` package contains classes that offer a simplified and more efficient way of working with files, and you'll see some useful examples here. But first I'd like to introduce a classes Path and Paths that will represent a file you're planning to work with. 

==== Using Classes Path and Paths

So far we worked with files located in the root directory of our IDEA project. But files are grouped in directories (folders), which in turn can include nested directories and files. More over, files are represented differently in Windows, Mac OS and Linux operational systems. For example, in Windows the pull path to a file may look like this:
_c:\mystuff\games\tictactoeScores.txt_

In Mac OS or Linux disks are not named with letters like _c:_ or _d:_. For example, the path to user's files starts from the _Users_ directory. Besides a backslash is not used for a separator symbol there. A full path to a file _tictactoeScores.txt_ of the user _mary_ may look like this:

_/Users/mary/mystuff/games/tictactoeScores.txt_

So before even opening a file you can create an instance of the object `Path`, which doesn't open or reads a file, but represents the location of the file on the disk. 

There is a special class `Paths` (yes, in plural) that includes a number of static methods, and in particular, can build the `Path` object for you. For example, you can invoke the method `get` passing the name of the file as the argument:

[source, java]
----
Path path = Paths.get("abc.dat");
----

Since we specified just the file name without a directory, the program will look for the file in the current directory, which in IDEA is the directory of your project (e.g. _Chapter11_). Outside of the IDE, the current directory is the one where the program was started from.

But if we were to create a directory _data_ at the root of our project and move the file _abc.dat_ there, then the _relative path_ to the file starting from the project root would look as `"data/abc.dat"` on Mac OS or `"data\\abc.dat"` on Windows. Two backslashes in a Java string correspond to one backslash in the Windows operational system.

But your IDEA project is also located in some directory on disk, e.g. _chapter11_, which is a subdirectory of _practicalJava_. The file can be represented by the _absolute path_, which may look like this:

_c:\practicalJava\chapter11\data\abc.dat_

or 

_/Users/mary/practicalJava/chapter11/data/abc.dat_


==== Using the Class Files

The class `Files` has several methods that will help you with file manipulations. It can create, delete, rename and copy files. There are methods to read and write files too.  

==== Reading a File

The simplest way to read a file is by calling the method `readAllBytes` on the class `Files`. The following line reads the file _abc.dat_ into an array of bytes:

[source, java]
----
byte[] myFileBytes = Files.readAllBytes(Paths.get("abc.dat");
----

If the file contains text, you can read the file into a `String` variable like this:

[source, java]
----
String myFileText = new String(Files.readAllBytes(Paths.get("abc.dat")));  
----

If you want to read a text file into a collection, where each element contains one line from the file use the method `readAllLines`.  

[source, java]
----
List<String> myFileLines = Files.readAllLines(Paths.get("abc.dat"));
----

Both `readAllBytes` and `readAllLines` do not use buffers, but for small files is not important.  For more efficient reading you can ask the class `Files` to create a buffered stream. For example, the program `MyTextFileReader` uses the method `newBufferedReader` for more efficient reading. Here I used the same file _abc.dat_ located in the root directory of our IDEA project Chapter11. 

[source, java]
----
package niosamples;

import java.io.BufferedReader;
import java.io.IOException;
import java.nio.charset.Charset;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;

public class MyTextFileReader {

  public static void main(String[] args){

    Path path = Paths.get("abc.dat");     // <1>
    System.out.println("The absolute path is " + 
                         path.toAbsolutePath());

    try {
      if ( Files.exists(path)){         // <2>
          System.out.println("The file size is " + Files.size(path));
      }

      BufferedReader bufferedReader=    // <3>
               Files.newBufferedReader(path, StandardCharsets.UTF_8);

      String currentLine;

      while ((currentLine =             // <4>
             bufferedReader.readLine()) != null){

        System.out.println(currentLine);

      }
    } catch (IOException ioe) {
        System.out.println("Can't read file: " +
                             ioe.getMessage());
    }

    System.out.println(             // <5>
           "Your default character encoding is " + Charset.defaultCharset());
  }
}
---- 

<1> The program starts with creating a `Path` object from _abc.dat_ and printing its absolute path.

<2>  Then it checks if the file represented by the path exists and prints its size in bytes.

<3>  Here we're opening the buffered reader capable of reading text encoded with a character set `UTF-8`.

<4> Reading the text lines from the buffer. 

<5> Print the default character set being used for those who are interested.

When I ran the program `MyTextFileReader` it printed the following:

[source, java]
----
The absolute path is /Users/yfain11/IdeaProjects/jfk/Chapter11/abc.dat
The file size is 19
This is a test file
Your default character encoding is UTF-8
----

Now make an experiment to see if the `IOException` is thrown if the file is not found where expected to be. Just move the file _abc.dat_ into a different directory and re-run `MyTextFileReader`. Now the console output looks different:

[source, java]
----
Can't read file: abc.dat
Your default character encoding is UTF-8
----
This output was produced by the `catch` section from `MyTextFileReader` where the code invoked the `getMessage` method on the `IOException` object.  

==== Writing Into a File

Writing into a file is as reading one. Start with creating create an instance of the `Path` object.  If you want to write bytes, create a byte array, populate it with data and call the method `write` on the class `Files`. If you want to write some text into a file, just convert the text from a `String` into a byte array and then call the method `write`, for example:

[source, java]
----
Path path = Paths.get("data/scores.txt");

Files.write(path, myScore.getBytes(),
                    StandardOpenOption.APPEND);
----

When your program opens a file for writing, you need to consider different options. For example, you may want to append text to an existing file, hence the above code snippet passes the argument  `StandardOpenOption.APPEND` to method `write`. If you want to create a file from scratch every time you run the program, use the option `StandardOpenOption.CREATE`.

The following program `MyTextFileWriter` writes the text into a file `scores.txt` in the directory `data`.

[source, java]
----
package niosamples;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;

public class MyTextFileWriter {

  public static void main(String[] args){

    System.out.println("The current directory is "+
         System.getProperty("user.dir"));   // <1>

    String myScore =                        // <2>
                "My game score is 28000 " + 
                     LocalDateTime.now() + "\n";

    Path path = Paths.get("data/scores.txt"); // <3>

    try {

        if ( Files.exists(path)){            // <4>
            Files.write(path, myScore.getBytes(),
                      StandardOpenOption.APPEND);
        } else {
            Files.write(path, myScore.getBytes(),
                      StandardOpenOption.CREATE);
        }

        System.out.println("The game score was saved at " + path.toAbsolutePath());
    } catch (IOException ioe) {
        System.out.println("Can't write file: " 
                             + ioe.getMessage());
    }
  }
}
----

<1> For illustration purposes I want the program to print its current directory, which is stored in a special Java variable `user.dir`.

<2> Then I populate a string with the content "My game score is 28000" and concatenate the current date and time followed by `\n`, which is the end of line marker.

<3> Creating a `Path` object pointing at the file `score.txt`.

<4> Check if the file `score.txt` already exists, append the new content to it. If the file doesn't exists – create it and write the content there.

The program `MyTextFileWriter` printed the following on my console:

[source, java]
----
The current directory is /Users/yfain11/IdeaProjects/jfk/Chapter11
The game score was saved at /Users/yfain11/IdeaProjects/jfk/Chapter11/data/scores.txt
----

After running `MyTextFileWriter` twice I opened the file _scores.txt_. Here's what I found there:

[source, java]
---- 
My game score is 28000 2015-01-11T09:07:49.352
My game score is 28000 2015-01-11T09:10:11.049
----

Each time the program saved the same score of 28000
attaching the system date and time. Of course, you could calculate and write the real score of a game. This is a simple way of printing the local date and time. The time portion goes after the letter "T" and shows hours, minutes, seconds, and nanoseconds. In the Java package `java.time` you can find multiple classes and methods providing formatting date and time for pretty printing. Go through Oracle's tutorial on working with http://docs.oracle.com/javase/tutorial/datetime/TOC.html[Date and Time API] if interested. 

For writing small files like _scores.txt_ you don't need to use buffered streams. For large files though, use BufferedWriter, for example:

[source, java]
----
String myScore = "My game score is 28000 " + 
                    LocalDateTime.now() + "\n";
BufferedWrited writer = Files.newBufferedWriter(path, StandardOpenOption.APPEND);

writer.write(myScore)
----

The class `MyTextFileBufferedFileWriter` shows how to write the game score using `BufferedWriter`.

[source, java]
----
package niosamples;

import java.io.BufferedWriter;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.StandardOpenOption;
import java.time.LocalDateTime;

public class MyTextFileBufferedFileWriter {

  public static void main(String[] args) {

    String myScore = "My game score is 28000 " + LocalDateTime.now() + "\n";

    Path path = Paths.get("data/scores.txt");

    try (BufferedWriter writer = 
                    getBufferedWriter(path)) {
        
        writer.write(myScore);

        System.out.println("The game score was saved at " + path.toAbsolutePath());
    } catch (IOException ioe) {
        System.out.println("Can't write file: " + 
                                  ioe.getMessage());
    }
  }

  // The factory of BufferedWriter objects
  private static BufferedWriter getBufferedWriter(Path path) throws IOException{

      if (Files.exists(path)) {
          return Files.newBufferedWriter(path,
                        StandardOpenOption.APPEND);
      } else {
          return Files.newBufferedWriter(path,
                         StandardOpenOption.CREATE);
      }
  }
}
----

In this class I've moved the code that check if the file exists into a separate method `getBufferedWriter`. I did it to illustrate so-called _factory design pattern_. A factory can build different objects, right?  The method `getBufferedWriter` also builds different instances of a `BufferedReader` depending on the existence of the file referred by `path`. In programmers jargon the methods that create and return different object instances based on some parameter are called factories.    

If you run the program `MyTextFileBufferedFileWriter` it'll produce the same results as `MyTextFileFileWriter`. If you use these programs for writing short texts you won't notice the difference in the speed of execution. But when you need to write large amount of information  `MyTextFileBufferedFileWriter` will work faster.


=== Serialization: Turning an Object Into Bytes

Imagine a building that, with a push of a button, can be turned into a pile of construction materials. Load all these materials on the truck and drive to a different city. On arrival push another button, and the building is magically re-created in its original form. This is what Java serialization is about, but instead of a building we'll use a Java object. By “clicking the serialize button” JVM turns an instance of an object into a pile of bytes, and “clicking the deserialize button” re-creates the object.

Why would you need such functionality? Say you are working on a board game and want to be able to save the current state of the game so the player and continue playing it tomorrow even if the computer will need to be turned off. The program needs to save the state of the game in a file, and when the player launches the game again, the program should load the saved state and recreate the situation on the board.  Creating a Java class with fields like player name, level, score, lives can be a good way to represent a state of the game. 

[source, java]
----
class GameState {
   String playerName;
   int level;
   int score;
   int remainingLives; 

   // other fields go here
}
----

When the user selects the menu option _Save Game State_, the program has to create an instance of the object `GameState`, assign the values to its fields and save these values in a file. But which format to save these values in? Create a `String` variable, and concatenate all these values into it separating the values with commas? It's a lot of work. Also, you'd need to remember the order of these concatenated values so when you need to read them you know to which fields of the object `GameState` to assign them to.

Luckily, Java greatly simplifies this process. You can create and instance of the Java object, populate it with the values, and then _serialize_ this instance into a bunch of bytes in a special format that remembers the structure of the class `GameState`. Accordingly, when you need to re-create the instance of the `GameState` for these bytes, you can _deserialize_ the object in one shot with all its fields values.

Let's see serialization in action. 


=== Project: Saving the Game Scores

