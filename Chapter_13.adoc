:toc-placement!:
:imagesdir: ./

== Chapter 13. Creating a Ping-Pong Game 

In chapters 6, 7, and 10 you’ve learned how to create simple GUI with JavaFX using such components as buttons, labels and text fields.  This chapter is more about drawing and animating shapes. 

JavaFX includes the package http://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/package-summary.html[javafx.scene.shape], which includes such classes as `Circle`, `Rectangle`, `Line` and more.

Ping-Pong is a perfect game to illustrate the drawing and animating capabilities of JavaFX. In this game you'll have another chance to work with event handlers, and will use multi-threading. 

=== The Strategy

Let’s come up with some rules of our Ping-Pong game:

1. This game will have two players named Kid and Computer. The table should be painted green, the left paddle should be painted blue - it'll be controlled by the Computer. The right paddle should be yellow - it's controlled by the Kid. Initially the red ball should be located in the center of the table.

2.  A new game starts when a player presses the N-key on the keyboard, pressing Q will end the game, and the S-key will serve the ball. Only the kid can serve the ball.

3. The Kid’s paddle movements should be controlled by the Up and Down arrow keys. Pressing the key once should move the paddle vertically by the preset number of pixels up or down. The paddle shouldn't cross the table borders.

4.  When the Kid presses the S-key, the ball should start moving at an angle toward the left side. To win a point the ball should go beyond the paddle when it's not blocking the ball. Computer's paddle moves up or down depending on the direction of the ball movement.

5.  When the Computer bounces the ball, it can move only horizontally to the right.

6.  If the ball contacts the Kid’s paddle in the upper half of the table, the ball should be moving in the up-and-left direction.  If the ball was located in the bottom part of the table, it should move in the down-and-left direction.

7.  The game lasts until one of the players reaches the score of 21. The game score should be displayed in the left bottom corner of the table.

At first, it seems to be a very challenging task. In programming we often have to break the complicated problem into a set of smaller and simpler tasks. The ability to do so is called _analytical thinking_, and it helps not only in programming, but  everywhere in your life. Do not get frustrated if you can’t achieve a big goal, split it in a set of the smaller ones an reach them one at time!  

Let's start breaking our complex task. Try to visualize a ping-pong table. Can you write a program that will draw a green rectangle? That’s our first goal to achieve. Then we'll add the paddle. Then we'll see how to draw the ball. Learning how to move the ball will be the next task. Writing the keyboard event handlers shouldn't be too difficult.

[[FIG13-1]]
image::images/fig_13_PingPong.png[]

Now let's implement each step from the game strategy, one step at a time.

=== Step 1: Creating the Table

In this section or goal is to draw a 2D ping-pong table, which should look as a green rectangle. 

Let's start with creating a new JavaFX project in IntelliJ IDEA selecting JavaFX as a project type. Press Next, and on the next popup window enter PingPong as a project name. Press the button Finish and IDEA will generate a new project for you. Rename (right-click | Refactor | Rename) the file _sample.fxml_ into _pingpong.fxml_, the `Main` class into `PingPong`, and `Controller` into `PingPongController`. The same way change the name of the package from _sample_ to _pong_. 

Now let's draw the ping-pong table in Scene Builder. Right-click on the file _pingpong.fxml_ and open it in Scene Builder. As you've seen in Chapter 7, the generated FXML uses the `<GridBag>` as a default container, and you'll see an empty `GridBag` in the Hierarchy pane. The left side of the SceneBuilder panels will look as follows:

[[FIG13-2]]
image::images/fig_13_Group.png[]

But I'm not going to use any layouts in the PingPong game. The game will consist of a number of shapes that I'll keep in the `Group` container. We haven't use it yet - the `Group` is used just to keep several child components together. Grouping components in a container can come handy, if you need to assign one event handler to all child components or auto-resize all of them as a group.

In Scene Builder delete the GridBag container and drag/drop the Group from the Miscellaneous section down to the Hierarchy pane. Then drag/drop a `Rectangle` from the Shapes panel onto the Group. Resize it an pick a nice green color from the Fill property on the right side (you'll be picking a color from a dropdown palette, and the color code will be inserted automatically). Your Screen Builder should look like this:

[[FIG13-3]]
image::images/fig_13_Rectangle.png[]

Open the file pingpong.fxml and you'll see the tag `<Rectangle>` inside the `<Group>` generated by Scene Builder. Set the width of the `Rectangle` to 400, and the height to 250. It should look like this:

[source, xml]
----
<?xml version="1.0" encoding="UTF-8"?>

<?import javafx.scene.shape.*?>
<?import javafx.scene.*?>
<?import java.lang.*?>
<?import javafx.scene.layout.*?>
<?import javafx.geometry.Insets?>
<?import javafx.scene.layout.GridPane?>
<?import javafx.scene.control.Button?>
<?import javafx.scene.control.Label?>

<Group xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Rectangle arcHeight="5.0" arcWidth="5.0" fill="#31b287" height="250" stroke="BLACK" strokeType="INSIDE" width="400" />
   </children>
</Group>
----

The `archHeight` and `arcWidth` were auto-generated in case you need to create rounded corners in the rectangle. The properties `stroke` and `strokeType` define the look of the rectangle's border. We don't really need to change the default values for these properties, but if you're interested in learning what are they for  visit the http://docs.oracle.com/javase/8/javafx/api/javafx/scene/shape/Rectangle.html[online documentation] for this class.  
Running the auto-generated `PingPong` class will show the following window:

[[FIG13-4]]
image::images/fig_13_HelloWorld.png[]

There are a couple of things that I don't like here. First, the corners of the rectangle are rounded just a little bit. This is caused by the properties `archHeight` and `arcWidth`. I'll remove them from `pingpong.fxml`.  

Second, the window has a title Hello World set by the auto-generated code in IntelliJ IDEA set this title. It's easy to change in the class `PingPong`, but I don't event want to see the title bar! 

This is also an easy change in JavaFX. Set the stage style to `UNDECORATED` will remove the standard window title and borders. But if I'll remove the title bar, I'll lose the ability to close the window by clicking on the circle (or a little cross in Windows) will be gone. A bit later we'll write the code to close the window by pressing the Q-key on the keyboard. At this point the code of the `PingPong` class looks like this:

[source, java]
----
package pong;

import javafx.application.Application;
import javafx.fxml.FXMLLoader;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.stage.Stage;
import javafx.stage.StageStyle;

public class PingPong extends Application {

 @Override
 public void start(Stage primaryStage) throws Exception{

    Parent root = FXMLLoader.load(getClass().getResource("pingpong.fxml"));

    primaryStage.setScene(new Scene(root, 400, 250));
    primaryStage.initStyle(StageStyle.UNDECORATED);
    primaryStage.show();
 }


 public static void main(String[] args) {
     launch(args);
 }
}
----

This class was generated by IDEA, but I've removed the Hello World title, set the size of the scene to 400 by 250 pixels, and added the line
`primaryStage.initStyle(StageStyle.UNDECORATED);`. Running the `PingPong` class will display the following green rectangle:

[[FIG13-5]]
image::images/fig_13_undecorated.png[]

Now let's open _pingpong.fxml_ in Scene Builder again add the paddles and the ball on top of the table. For paddles, I'll drag/drop two `Rectangle` objects from the Shapes section onto the Group container. Our paddles will have size of 10 by 50 pixels. The left paddle will be blue, aand the right one - yellow. Then I drag/drop, resize and color the `Circle` setting its radius to 9 pixels and painting it red. My Scene Builder will look like this:

[[FIG13-6]]
image::images/fig_13_paddles_and_ball.png[]

Now back to IDEA. Since our shapes will need to communicate with the controller class, we need to assign an `fx:id` to each of them. Let's assign the `fx:id="theGroup"` to the `Group` container. Our green `Rectangle` will get `fx:id="table"`. 

Computer will play with the left paddle, and I'll give it `fx:id="compPaddle"`. The Kid will play with the right paddle that will go by `fx:id="kidPaddle"`. The ball will get `fx:id="ball"`. Now The `Group` container in my file _pingpong.fxml_ will look like this: 

[source, xml]
----
<Group fx:id="theGroup" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
   <children>
      <Rectangle fx:id="table" fill="#31b287" height="250" stroke="BLACK" strokeType="INSIDE" width="400" />
      <Rectangle fx:id="compPaddle" arcHeight="5.0" arcWidth="5.0" fill="DODGERBLUE" height="50.0" layoutX="24.0" layoutY="98.0" stroke="BLACK" strokeType="INSIDE" width="10.0" />
      <Rectangle fx:id="kidPaddle" arcHeight="5.0" arcWidth="5.0" fill="#f0ff1f" height="50.0" layoutX="365.0" layoutY="98.0" stroke="BLACK" strokeType="INSIDE" width="10.0" />
      <Circle fx:id="ball" fill="#ff1f35" layoutX="191.0" layoutY="123.0" radius="9.0" stroke="BLACK" strokeType="INSIDE" />
   </children>
</Group>
----

Running the `PingPong` program will display the following ping-pong table:

[[FIG13-7]]
image::images/fig_13_table_paddles_and_ball.png[]

Drawing of the GUI is complete, now we need to take care of the user interactions, which will be done in the class `PingPongController`. In _pingpong.fxml_ we need to assign this class as the `fx:controller` to the `Group` (see Chapter 8 for a refresher):

[source, xml]
----
<Group fx:id="theGroup" fx:controller="pong.PingPongController" xmlns="http://javafx.com/javafx/8" xmlns:fx="http://javafx.com/fxml/1">
----

Dear Scene Builder and FXML, you've been very helpful. Now I'm happily going back to Java programming.

=== Step 2: Handling Keyboard Events

We need to add the event handler methods to the class `PingPongController` to process keyboard events. Every key on the keyboard has a special code assigned, and our first goal is to figure out which key the player pressed. 

For processing keyboard events JavaFX components have special event handler properties `onKeyPressed`, `onKeyReleased`, and `onKeyTyped`. The first two properties allow you to program different actions for the downward and upward key motions, if needed. 

The `onKeyTyped` is used to assign a handler to the event when the key code is sent to the system output. This event is http://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/KeyEvent.html[not generated] for the keys that don't produce character output. We'll use `onKeyReleased` - this is when the the user lift his finger up.

NOTE: IDEA can help you to find out which event handlers can be used with a particular component. Just click CTRL-Space inside this component's FXML tag and start typing with the letters `on` - you'll see all applicable event handlers. 

When the user releases a key, the `onKeyReleased` method handler receives the `KeyEvent` object as an argument. The method `getCode` from the class `KeyEvent` returns the `KeyCode` object that represents the key pressed. For example, if you press the button Q, the `getCode` will return `Q`. If you press the arrow up, the `getCode` will return `UP`.

But the same key can result in displaying more than one character (e.g. Q or q) The method `getText` of `KeyEvent` returns a `String` that represents the character typed by the user.

To enable our GUI to react on keyboard events right after the program starts, we need to _set the focus_ on the GUI. This was not required when we clicked on the GUI components with the mouse, but now we won't even touch the screen.

To set the focus to the `Group` container we'll need to do two things:

1. Enable the `Group` to receive the focus by useing the attribute `focusTraversable="true"` in _pingpong.fxml_.

2. Right after the stage is displayed in the `PingPong` class, we'll call the method `requestFocus` on the `Group` container. The method `start` in `PingPong` will look like this (I've added just the last line to the code generated by IDEA):
+
[source. java]
----
 public void start(Stage primaryStage) throws Exception{

  Parent root = FXMLLoader.load(getClass().getResource("pingpong.fxml"));

  primaryStage.setScene(new Scene(root, 400, 250));
  primaryStage.initStyle(StageStyle.UNDECORATED);

  primaryStage.show();
  root.requestFocus();
}
----

==== The First Version of Controller

Next, we need to add to the `PingPongControler` a method handler for the key-released events. The first very simple version of the `PingPongControler` is shown next. The goal is to see that the controller receives the keyboard events and can recognize the keys pressed by the player.

[source, java]
----
package pong;

import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

public class PingPongController {

  public void keyReleasedHandler(KeyEvent event){

    KeyCode keyCode =  event.getCode();
    System.out.println("You pressed " + keyCode);
  }
}
----

The event handler method just extracts the key code from the `KeyEvent` object provided by the Java runtime and prints it. 
For example, after running the `PingPong` class and pressing the up and down arrows, _n_, _q_, and _s_ keys, the console output should look like this:

[source, html]
----
You pressed UP
You pressed DOWN
You pressed N
You pressed Q
You pressed S
---- 

The `KeyCode` in `PingPongController` is not a class or an interface, but a special Java construct called `enum` described next.  

==== The enum Type

Our controller class declares a variable of type `KeyCode`, which is neither a class nor an interface. It's a special Java data type `enum` used for declaring a bunch of pre-defined constants that never change. For example, you can declare a new `enum` type day-of-the-week:

[source, java]
----
public enum Day {
    SUNDAY, MONDAY, TUESDAY, WEDNESDAY,
    THURSDAY, FRIDAY, SATURDAY 
}
----

The following class `GreetTheDay` illustrates the use of the `enum Day`:

[source, java]
----
public class GreetTheDay {

  public static void main(String[] args) {

    greet(Day.SATURDAY);
  }

  static void greet(Day day){
    switch (day) {
        case MONDAY:
            System.out.println("The week begins");
            break;
        case SATURDAY:
        case SUNDAY:
            System.out.println("Hello Weekend!");
            break;
        default:
            System.out.println("Hello Midweek");
            break;
    }
  }
}
----

The method `greet` expects to receive one of the `Day` values as an argument. Our `main` method wants to greet Saturday, and if you run the program `GreetTheDay` it'll print _Hello Weekend!_.

If you'll open the http://docs.oracle.com/javase/8/javafx/api/javafx/scene/input/KeyCode.html[online documentation] for `KeyCode` you'll find there the declarations of all possible keyboard keys.

==== The Second Version of Controller

Now we'll add a `switch` statement to the controller to invoke the method that corresponds to the pressed key. Let's not worry about implementing the application logic just yet. We want to make sure that the programs invokes the correct method for each key. 

[source, java]
----
package pong;

import javafx.application.Platform;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;

public class PingPongController {

  public void keyReleasedHandler(KeyEvent event){

    KeyCode keyCode = event.getCode();

    switch (keyCode){
      case UP:
          process_key_Up();
          break;
      case DOWN:
          process_key_Down();
          break;
      case N:
          process_key_N();
          break;
      case Q:
          Platform.exit(); // Terminate the app
          break;
      case S:
          process_key_S();
          break;
      }
  }

  private void process_key_Up() {
    System.out.println("Processing the Up key");
  }

  private void process_key_Down() {
    System.out.println("Processing the Down key");
  }

  private void process_key_N() {
    System.out.println("Processing the N key");
  }

  private void process_key_S() {
    System.out.println("Processing the S key");
  }
}
----

The `switch` statement checks the value of `enum KeyCode` and calls the corresponding method which just prints a hard-coded message - we'll implement them shortly. But the Q-key in the above `PingPongController` is fully functional. When the user presses the Q-key, the program invokes the method `exit` on the class `Platform`, which terminates the program.      

=== Step 3: Moving the Paddle

Now let's teach the keys Up and Down to move the kid's paddle vertically. Pressing the Up-arrow should move the kid's paddle several pixels up according to the predefined moving increment. Pressing the Down-arrow should move the paddle down. We'll declare an movement increment as a `final` variable in `PingPongController`:

[source, java]
----
final int PADDLE_MOVEMENT_INCREMENT = 7;
---- 
Pressing the key once will change the vertical position of the paddle by 7 pixels. Seven is not a magical number, and you can use any other integer here.

The new version of the controller will use the `@FXML` annotations to inject the references to the GUI components. To update the position of the kid's paddle on the GUI we'll use data binding explained in Chapter 8. We'll also add the method `initialize` that is invoked by the Java runtime once when the controller object is created. Finally, we'll write the code in the methods `process_key_Down` and `process_key_Up` to move the kid's paddle vertically. 

In JavaFX the x and y coordinates of the top left corner of the stage have zero values. x-coordinate increases from left to right, and the y-coordinate increases from top to bottom. The paddles can move only up or down, so depending on the key pressed we'll be changing the value of the property `layoutY` of the right paddle, which will move it on stage accordingly. Here's how the `PingPongController` will look now:

[source, java]
----
package pong;

import javafx.application.Platform;
import javafx.beans.property.DoubleProperty;
import javafx.beans.property.SimpleDoubleProperty;
import javafx.fxml.FXML;
import javafx.scene.input.KeyCode;
import javafx.scene.input.KeyEvent;
import javafx.scene.shape.Circle;
import javafx.scene.shape.Rectangle;

public class PingPongController {

  final int PADDLE_MOVEMENT_INCREMENT = 6;

  DoubleProperty currentKidPaddleY = 
              new SimpleDoubleProperty();   // <1>

  double allowedPaddleTopY;                 // <2> 
  double allowedPaddleBottomY;

  @FXML Rectangle table;                    // <3>
  @FXML Rectangle compPaddle;
  @FXML Rectangle kidPaddle;
  @FXML Circle ball;

  public void initialize() {               

    currentKidPaddleY.set(kidPaddle.getLayoutY());  // <4>
    kidPaddle.layoutYProperty().bind(currentKidPaddleY);

    allowedPaddleTopY = PADDLE_MOVEMENT_INCREMENT; // <5> 
    allowedPaddleBottomY = table.getHeight() - kidPaddle.getHeight() - PADDLE_MOVEMENT_INCREMENT;

    
  }

  public void keyReleasedHandler(KeyEvent event){

    KeyCode keyCode = event.getCode();

    switch (keyCode){
        case UP:
            process_key_Up();
            break;
        case DOWN:
            process_key_Down();
            break;
        case N:
            process_key_N();
            break;
        case Q:
            Platform.exit(); // Terminate the application
            break;
        case S:
            process_key_S();
            break;
    }
  }

  private void process_key_Up() {      // <6>

    if (currentKidPaddleY.get() > allowedPaddleTopY) {
        currentKidPaddleY.set(currentKidPaddleY.get() - PADDLE_MOVEMENT_INCREMENT);
    }
  }

  private void process_key_Down() {      // <7>

    if (currentKidPaddleY.get()< allowedPaddleBottomY) {
        currentKidPaddleY.set(currentKidPaddleY.get() + PADDLE_MOVEMENT_INCREMENT);
    }
  }

  private void process_key_N() {
     System.out.println("Processing the N key");
  }

  private void process_key_S() {
     System.out.println("Processing the S key");
  }
}
----

<1> Declaring the property `currentKidPaddleY` that will be bound to the property `layoutY` of the kid's paddle.

<2>	The Kid will be moving the paddle up and down, but we don't want to allow the paddle to leave the table boundaries. The variable `allowedPaddleTopY` will store the maximum allowed y-coordinate for the top of the paddle, and the `allowedPaddleBottomY` will have the maximum allowed y-coordinate for the bottom of the paddle.

<3> Using @FXML tag we inject the references to the GUI components defined in _pingpong.fxml_ into the controller's variables.

<4> The method `initialize` in the controller is called only once and is the right place to initialize important variables. First, we initialize the property `currentKidPaddleY`, with the value of the `layoutY` property of the right paddle (the _kidPaddle_ component has an attribute `layoutY="98.0"` in the file _pingpong.fxml_). Then we bind `currentKidPaddleY` to the  `layoutY` property of the GUI component kidPaddle.

<5> Here we set the limits for the paddle movements. We set the variable `allowedPaddleTopY=PADDLE_MOVEMENT_INCREMENT` to make sure that if the Kid keeps pressing the Up arrow, the paddle will never cross the top border of the table. The bottom restriction `allowedPaddleBottomY` is calculated by subtracting the height of the paddle and `PADDLE_MOVEMENT_INCREMENT` from the table height. 
<6> The method `process_key_Up` gets the current y-coordinate of the top border of the paddle, and if it's far enough from the table top, the code decrements the value of the property `currentKidPaddleY` by `PADDLE_MOVEMENT_INCREMENT`. Because `currentKidPaddleY` is bound to the `layoutY` property of the GUI component `kidPaddle`, the latter moves up on stage. The movement stops if the `currentKidPaddleY` value is higher than `allowedPaddleTopY`. Remember, the y-coordinate increases from top down, so the higher y-coordinates means that it's physically lower on stage.

<7> The method `process_key_Down` works similarly to `process_key_Up` but ensures that the paddle won't cross the bottom border of the table.   	

Now our controller knows how to move the Kid's paddle. The next challenge is to learn how to move the ball.

=== Step 4. Moving the Ball

The class `javafx.animation.Timeline` allows you to change the values of properties over a time interval. For example, if you'll be changing a Y coordinate of a paddle every second, it'll be moving vertically on the scene.  

The paddle is an instance of the `Line` so we'll be changing the value of its startY attribute for times a second. 

=== Project: Displaying the Game Score